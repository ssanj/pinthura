#labels FilterChainImpl,ChainofResponsibility
Describes the {{{FilterChainImpl}}} class.

= Introduction =

The {{{FilterChainImpl}}} is an implementation of the (Gof) [http://dofactory.com/Patterns/PatternChain.aspx Chain of Responsibility] pattern. 

The basic premise is, that, one of many handlers, may handle a given input. At runtime each handler will be given a chance to handle the input. If it can't handle the input, it passes it to the next handler in the chain, until a handler is found or all handlers are exhausted.

= Why use the Chain of Responsibility? =

 # Decouples the sender of a request from the object that handles the request.
 # Dynamically updating the chain of handlers for a given request. (no if-else nastiness)


= How {{{FilterChainImpl}}} implements the Chain of Responsibility =

The {{{FilterChainImpl}}} class and the {{{FilterLink}}} interface are used to implement the COR pattern. In this setting the _Handlers_ are called {{{FilterLinks}}}. The {{{FilterChainImpl}}} is initialized through a constructor that takes in a {{{List<FilterLink>}}}. 

*Guidelines for implementing the {{{FilterLink}}} interface*:
 # Each implementation in the List of {{{FilterLink}}}s have to accept the same input and same output types.
 # If the {{{FilterLink}}} can handle the input, it must return the result. 
 # A {{{FilterLink}}} must throw a {{{MatchNotFoundException}}} to indicate it can't handle the input.
 # Each {{{FilterLink}}} will be called multiple times. The state of the {{{FilterLink}}} implementation should remain constant between calls.

*Guidelines for using the {{{FilterChainImpl}}} class*:

 # The {{{FilterChainImpl}}} class is an implementation of the {{{FilterLink}}} interface and may throw a {{{MatchNotFoundException}}} if none of the supplied {{{FilterLink}}}s can handle the input. In such a situation, catching the {{{MatchNotFoundException}}} and rethrowing a more specific exception is encouraged:

Eg.

{{{

try {
  filterChain.filter(fileName);
} catch (MatchNotFoundException e) {
   throw new ConfigFileNotFoundException(e);
}

}}}

= A Mail Example =

This example models a simple mail filtering system that filters mail based on:

 # Whether it has marketing information. (spam)
 # If it has large attachments.
 # If it has neither of the above (Inbox)

*Each `FilterLink` accepts a `Mail` instance as Input and returns a `Boolean` as Output.*

The {{{SpamFilter}}}:

{{{
public final class SpamFilter implements FilterLink<Mail, Boolean> {

    private final SpamDetector spamDetector;
    private final MailMan mailMan;

    public SpamFilter(final SpamDetector spamDetector, final MailMan mailMan) {
        this.spamDetector = spamDetector;
        this.mailMan = mailMan;
    }

    public Boolean filter(final Mail mail) throws MatchNotFoundException {
        if (spamDetector.isSpam(mail)) {
            mailMan.moveMail(MailLocationEnum.SPAM);
            return true;
        }

        throw new MatchNotFoundException();
    }

    public String getFilterName() {
        return "Spam Filter";
    }
}
}}}

The {{{LargeAttachmentFilter}}}:

{{{
public final class LargeAttachmentFilter implements FilterLink<Mail, Boolean> {

    private final MailMan mailMan;
    private final long attachmentLimit;

    public LargeAttachmentFilter(final long attachmentLimit, final MailMan mailMan) {
        this.mailMan = mailMan;
        this.attachmentLimit = attachmentLimit;
    }

    public Boolean filter(final Mail mail) throws MatchNotFoundException {
        if (mail.getAttachmentSize() > attachmentLimit) {
            mailMan.moveMail(MailLocationEnum.LARGE_ATTACHMENTS);
            return true;
        }

        throw new MatchNotFoundException();
    }

    public String getFilterName() {
        return "Large Attachment Filter";
    }
}
}}}

The `InboxFilter`:

{{{
public final class InboxFilter implements FilterLink<Mail, Boolean> {

    private final MailMan mailMan;

    public InboxFilter(final MailMan mailMan) {
        this.mailMan = mailMan;
    }

    public Boolean filter(final Mail mail) throws MatchNotFoundException {
        mailMan.moveMail(MailLocationEnum.INBOX);
        return true;
    }

    public String getFilterName() {
        return "Inbox Filter";
    }
}
}}}

The `MailImpl`:

{{{
public final class MailImpl implements Mail {

    private final long attachmentSize;
    private final boolean sellingSomething;

    public MailImpl(final long attachmentSize, final boolean sellingSomething) {
        this.attachmentSize = attachmentSize;
        this.sellingSomething = sellingSomething;
    }

    public long getAttachmentSize() {
        return attachmentSize;
    }

    public boolean isSellingSomething() {
        return sellingSomething;
    }
}
}}}

The `MailFilterRunner`:

{{{
public final class MailFilterRunner {

    private static final int ATTACHMENT_LIMIT_OF_50 = 50;
    private static final int ATTACHMENT_OF_40       = 40;
    private static final int ATTACHMENT_OF_60       = 60;
    private static final int ATTACHMENT_OF_100      = 100;

    private MailFilterRunner() { }

    public static void main(final String[] args) {
        List<FilterLink<Mail, Boolean>> filters = new ArrayList<FilterLink<Mail, Boolean>>();
        MailManImpl mailMan = new MailManImpl();
        filters.add(new SpamFilter(new SpamDetectorImpl(), mailMan));
        filters.add(new LargeAttachmentFilter(ATTACHMENT_LIMIT_OF_50, mailMan));
        filters.add(new InboxFilter(mailMan));

        FilterLink<Mail, Boolean> chainOfResp = new FilterChainImpl<Mail, Boolean>(filters);

        chainOfResp.filter(new MailImpl(ATTACHMENT_OF_100, true)); //caught by the spam detector.
        chainOfResp.filter(new MailImpl(ATTACHMENT_OF_100, false)); //caught by the large attachment detector.
        chainOfResp.filter(new MailImpl(ATTACHMENT_OF_40, false)); //goes into the inbox.
        chainOfResp.filter(new MailImpl(ATTACHMENT_OF_60, false)); //caught by the large attachment detector.
    }
}
}}}
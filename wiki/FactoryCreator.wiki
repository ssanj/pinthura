#summary Describes the FactoryCreatorImpl class.
#labels Phase-Implementation,FactoryCreatorImpl,StartingPoint

== A Simple Example ==

Assume you have a `Square` interface:

{{{
public interface Square {

    int getLength();
    int getArea();
}
}}}

And an implementation:

{{{
public final class SquareImpl implements Square {

    private static final int SIDES_OF_SQUARE = 4;

    private final int length;

    public SquareImpl(final int length) {
        this.length = length;
    }

    public int getLength() {
        return SIDES_OF_SQUARE * length;
    }

    public int getArea() {
        return length * length;
    }
}
}}}

You now want to hide the instantiation of the `SquareImpl` behind a factory interface:

{{{
public interface SquareFactory {

    Square createSquare(int length);
 }
}}}

The `SquareFactory` is used in the `ShapeCanvas`:

{{{
public final class ShapeCanvas {

    private final SquareFactory squareFactory;
    private int canvasArea;

    public ShapeCanvas(final int canvasArea, final SquareFactory squareFactory) {
        this.canvasArea = canvasArea;
        this.squareFactory = squareFactory;
    }

    public int calcSquaresOnCanvas(int size) {
        Square square = squareFactory.create(size);
        int area = square.getArea();
        return canvasArea / area;
    }
}
}}}

The `ShapeCanvas` is run through the `ShapeCanvasRunner`:

{{{
public final class ShapeCanvasRunner {

    public static void main(final String[] args) {
        FactoryCreator factoryCreator = new FactoryCreatorImpl(new InvocationFactoryImpl());
        SquareFactory squareFactory = factoryCreator.create(SquareFactory.class);

        ShapeCanvas canvas = new ShapeCanvas(40, squareFactory);
        System.out.println("Number of squares: " + canvas.calcSquaresOnCanvas(2));
    }
}
}}}

This gives the following output:

{{{
Number of squares: 10
}}}

You have now created an instance a `SquareImpl` which is used in the `ShapeCanvas#calcSquaresOnCanvas` class, without using the `new` keyword or implementing the `SquareFactory` interface.

[FactoryCreatorImpl_Why_Hide_Instantiation_In_Factory Why Hide the Instantiation of Objects in a Factory?]
[FactoryCreatorImpl_Why_Need_FactoryCreator Why do I need the FactoryCreator?]
[FactoryCreatorImpl_Default_Locator_Strategies Where can I update the Default Locator Strategies?]

= Why Hide the Instantiation of Objects in a Factory? =

 # Ties the implementation class to the using class
 # Can't swap in/out implementations
 # Can't control the instance used within a test.

= Why do I need Factory anyways? =

Using the keyword *new* when driving out code, makes interactions hard to test. Instances created within a test case and those created within the code proper are different. We are forced to resort to state-based testing in these scenarios. 

One way to get around this is by passing in a factory interface to abstract object creation. 

For example take a factory interface that creates Reports:

{{{
package com.googlecode.pinthura.factory.report;

public interface ReportFactory {

    Report create(Information info);
}
}}}

A `ReportGeneratorImpl` that uses the `ReportFactory`:

{{{
package com.googlecode.pinthura.factory.report;

public final class ReportGeneratorImpl implements ReportGenerator {

    private final ReportFactory reportFactory;

    public ReportGeneratorImpl(final ReportFactory reportFactory) {
        this.reportFactory = reportFactory;
    }

    public void generate(final Information info) {
        reportFactory.create(info).generate();
    }
}
}}}


When driving out the `ReportGeneratorImpl` class, we can quite easily mock out the `ReportFactory` and perform behaviour-based testing via mocks. See [http://www.easymock.org/ EasyMock], [http://www.jmock.org/ jMock]

At some point we need a concrete implementation of the `ReportFactory` interface. The class that implements this interface may be simple but can be hard to test if it interacts directly with concrete classes. Thus in many instances these Factory implementations are not tested or have rudimentary tests that simply create a new instance of an object.

= Why do I need the FactoryCreator? =

The `FactoryCreatorImpl` manages the link between a factory interface and the concrete implementation, of each of the factory methods. This means that we don't need to write a concrete implementation and tests for the factory interface.

= How does FactoryCreator locate the Correct Implementations? =

At the moment, the `FactoryCreatorImpl` class finds implementations using two Locator strategies:

 # By annotation.
 # By generating an implementation class name derived from the interface name.

== How do I use the Annotation strategy? ==


== How do I use the Derived Implementation Name strategy? ==

Using the `FactoryCreatorImpl` to create a default factory implementation for the the `ReportFactory` interface:

{{{
package com.googlecode.pinthura.factory.report;

public interface ReportFactory {

    Report create(Information info);
}
}}}

{{{
    FactoryCreator factoryCreator = new FactoryCreatorImpl(new InvocationFactoryImpl());
    ReportFactory reportFactory = factoryCreator.create(ReportFactory.class);
    Report report = reportFactory.create(new InformationImpl());
}}}

Using the derived implementation name strategy, the implementation located for the `ReportFactory`'s create method is `ReportImpl`. This is done by simply appending an 'Impl' to the end of the return type for the create method on the ReportFactory interface. (`com.googlecode.pinthura.factory.report.Report`+'Impl' -> `com.googlecode.pinthura.factory.report.ReportImpl`.

== Where can I update the Default Locator Strategies? ==

The above default strategies are initialized in the the `InvocationFactoryImpl`
class:
{{{
public final class InvocationFactoryImpl implements InvocationFactory {

    private final List<ClassLocator> locators;
    private final MethodParamFactory factory;

    public InvocationFactoryImpl() {
        factory = new MethodParamFactoryImpl();
        locators = createDefaultLocators();
    }

    public InvocationFactoryImpl(final List<ClassLocator> locators) {
        factory = new MethodParamFactoryImpl();
        this.locators = locators;
    }

    ...

    private List<ClassLocator> createDefaultLocators() {
        List<ClassLocator> filters = new ArrayList<ClassLocator>();
        filters.add(new AnnotationLocatorImpl(new AnnotationFinderImpl()));
        filters.add(new DerivedImplementationNameLocator(new ImplSuffixingDeriver()));
        return filters;
    }
}
}}}

Calling the default constructor gives us the two default class locator strategies. If we want to customize these strategies we can pass in a list of our own ClassLocator implementations, through the second constructor.

The `ClassLocator` interface:

{{{
public interface ClassLocator extends FilterLink<MethodParam, Class<?>> {
}}}

= Examples =

 * [FactoryCreatorImplReportGenerator Report Generator]
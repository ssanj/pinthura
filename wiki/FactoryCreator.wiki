#summary Describes the FactoryCreatorImpl class.
#labels Phase-Implementation,FactoryCreatorImpl,StartingPoint

== A Simple Example ==

Assume you have a `Square` interface:

{{{
public interface Square {

    int getLength();
    int getArea();
}
}}}

And an implementation:

{{{
public final class SquareImpl implements Square {

    private static final int SIDES_OF_SQUARE = 4;

    private final int length;

    public SquareImpl(final int length) {
        this.length = length;
    }

    public int getLength() {
        return SIDES_OF_SQUARE * length;
    }

    public int getArea() {
        return length * length;
    }
}
}}}

You now want to hide the instantiation of the `SquareImpl` behind a factory interface:

{{{
public interface SquareFactory {

    Square createSquare(int length);
 }
}}}

The `SquareFactory` is used in the `ShapeCanvas`:

{{{
public final class ShapeCanvas {

    private final SquareFactory squareFactory;
    private int canvasArea;

    public ShapeCanvas(final int canvasArea, final SquareFactory squareFactory) {
        this.canvasArea = canvasArea;
        this.squareFactory = squareFactory;
    }

    public int calcSquaresOnCanvas(int size) {
        Square square = squareFactory.create(size);
        int area = square.getArea();
        return canvasArea / area;
    }
}
}}}

The `ShapeCanvas` is run through the `ShapeCanvasRunner`:

{{{
public final class ShapeCanvasRunner {

    public static void main(final String[] args) {
        FactoryCreator factoryCreator = new FactoryCreatorImpl(new InvocationFactoryImpl());
        SquareFactory squareFactory = factoryCreator.create(SquareFactory.class);

        ShapeCanvas canvas = new ShapeCanvas(40, squareFactory);
        System.out.println("Number of squares: " + canvas.calcSquaresOnCanvas(2));
    }
}
}}}

This gives the following output:

{{{
Number of squares: 10
}}}

You have now created an instance a `SquareImpl` which is used in the `ShapeCanvas#calcSquaresOnCanvas` class, without using the `new` keyword or implementing the `SquareFactory` interface.

 * [FactoryCreatorImpl_Why_Hide_Instantiation_In_Factory Why Hide the Instantiation of Objects in a Factory?]
 * [FactoryCreatorImpl_Why_Need_FactoryCreator Why do I need the FactoryCreator?]
 * [FactoryCreatorImpl_Default_Locator_Strategies Where can I update the Default Locator Strategies?]

= Why do I need the FactoryCreator? =

The `FactoryCreatorImpl` manages the link between a factory interface and the concrete implementation, of each of the factory methods. This means that we don't need to write a concrete implementation and tests for the factory interface.

= How does FactoryCreator locate the Correct Implementations? =

At the moment, the `FactoryCreatorImpl` class finds implementations using two Locator strategies:

 # By annotation.
 # By generating an implementation class name derived from the interface name.

== How do I use the Annotation strategy? ==


== How do I use the Derived Implementation Name strategy? ==

Using the `FactoryCreatorImpl` to create a default factory implementation for the the `ReportFactory` interface:

{{{
package com.googlecode.pinthura.factory.report;

public interface ReportFactory {

    Report create(Information info);
}
}}}

{{{
    FactoryCreator factoryCreator = new FactoryCreatorImpl(new InvocationFactoryImpl());
    ReportFactory reportFactory = factoryCreator.create(ReportFactory.class);
    Report report = reportFactory.create(new InformationImpl());
}}}

Using the derived implementation name strategy, the implementation located for the `ReportFactory`'s create method is `ReportImpl`. This is done by simply appending an 'Impl' to the end of the return type for the create method on the ReportFactory interface. (`com.googlecode.pinthura.factory.report.Report`+'Impl' -> `com.googlecode.pinthura.factory.report.ReportImpl`.

== Where can I update the Default Locator Strategies? ==

The above default strategies are initialized in the the `InvocationFactoryImpl`
class:
{{{
public final class InvocationFactoryImpl implements InvocationFactory {

    private final List<ClassLocator> locators;
    private final MethodParamFactory factory;

    public InvocationFactoryImpl() {
        factory = new MethodParamFactoryImpl();
        locators = createDefaultLocators();
    }

    public InvocationFactoryImpl(final List<ClassLocator> locators) {
        factory = new MethodParamFactoryImpl();
        this.locators = locators;
    }

    ...

    private List<ClassLocator> createDefaultLocators() {
        List<ClassLocator> filters = new ArrayList<ClassLocator>();
        filters.add(new AnnotationLocatorImpl(new AnnotationFinderImpl()));
        filters.add(new DerivedImplementationNameLocator(new ImplSuffixingDeriver()));
        return filters;
    }
}
}}}

Calling the default constructor gives us the two default class locator strategies. If we want to customize these strategies we can pass in a list of our own ClassLocator implementations, through the second constructor.

The `ClassLocator` interface:

{{{
public interface ClassLocator extends FilterLink<MethodParam, Class<?>> {
}}}

= Examples =

 * [FactoryCreatorImplReportGenerator Report Generator]
#summary Describes how to dynamically create factory implementations.
#labels Phase-Implementation,FactoryCreatorImpl,StartingPoint

== A simple example ==

Assume you have a `Square` interface:

{{{
public interface Square {

    int getLength();
    int getArea();
}
}}}

And an implementation:

{{{
public final class SquareImpl implements Square {

    private static final int SIDES_OF_SQUARE = 4;

    private final int length;

    public SquareImpl(final int length) {
        this.length = length;
    }

    public int getLength() {
        return SIDES_OF_SQUARE * length;
    }

    public int getArea() {
        return length * length;
    }
}
}}}

You now want to hide the instantiation of the `SquareImpl` behind a factory interface:

{{{
public interface SquareFactory {

    Square createSquare(int length);
 }
}}}

The `SquareFactory` is used in the `ShapeCanvas`:

{{{
public final class ShapeCanvas {

    private final SquareFactory squareFactory;
    private int canvasArea;

    public ShapeCanvas(final int canvasArea, final SquareFactory squareFactory) {
        this.canvasArea = canvasArea;
        this.squareFactory = squareFactory;
    }

    public int calcSquaresOnCanvas(final int size) {
        Square square = squareFactory.create(size);
        return canvasArea / square.getArea();
    }
}
}}}

The `ShapeCanvas` is run through the `ShapeCanvasRunner`:

{{{
public final class ShapeCanvasRunner {

    private static final int CANVAS_AREA = 40;

    private ShapeCanvasRunner() {
        //Main class.
    }

    public static void main(final String[] args) {
        FactoryCreator factoryCreator = new FactoryCreatorBuilder().build();
        SquareFactory squareFactory = factoryCreator.create(SquareFactory.class);

        ShapeCanvas canvas = new ShapeCanvas(CANVAS_AREA, squareFactory);
        System.out.println("Number of squares: " + canvas.calcSquaresOnCanvas(2));
    }
}
}}}

This gives the following output:

{{{
Number of squares: 10
}}}

You have now created an instance of `SquareImpl` which is used in the `ShapeCanvas#calcSquaresOnCanvas` method, without using the `new` keyword or implementing the `SquareFactory` interface.

= Why hide object creation in a factory? =

Here is an implementation of the `ShapeCanvas` where a `SqaureImpl` is created directly with `new` instead of using a factory:
{{{
public final class ShapeCanvas {

    ...

    public int calcSquaresOnCanvas(int size) {
        Square square = new SquareImpl(size);
        int area = square.getArea();
        return canvasArea / area;
    }
}

}}}
1. Dependencies on implementations - By directly `new`ing up an instance of a `SquareImpl`, the `ShapeCanvas` class now depends on the `SqaureImpl` class. Thus changing the the `SquareImpl` class directly affects the `ShapeCanvas`. This is not the case when using a factory as the implementation is hidden behind the `Square` inteface.

We also can't swap out the `SquareImpl` for another implementation of the `Sqaure` interface. We can do this via a factory as the factory returns a `Square` interface.

2. We can't test in isolation - We have to resort to state-bases tests as we can't [http://www.easymock.org/ mock] [http://www.jmock.org/ out] the `SquareImpl` class since it is created within the `calcSquaresOnCanvas()` method . When testing the `calcSquaresOnCanvas()` method, we would be testing both the `SquareImpl` class's `getArea()` method as well as the calcSquaresOnCanvas()` method in the same test.

If we use a factory to handle creation of `Square`s:

{{{
public final class ShapeCanvas {

    ...

    public ShapeCanvas(final int canvasArea, final SquareFactory squareFactory) {
       ...
    }

    public int calcSquaresOnCanvas(int size) {
        Square square = squareFactory.create(size);
        ...
    }
}

}}}

We can mock out the `SquareFactory` interface passed to the constructor very easily.

= What does the FactoryCreator give me? =

At some point we need a concrete implementation of the factory interface. In many instances these factory implementations are not tested or have rudimentary tests that simply create a new instance of an object. The `FactoryCreator` automates the implementation of a factory interface.  

In the above scenario the manual implementation of `SquareFactoryImpl` would be:
{{{
public final class SquareFactoryImpl implements SquareFactory {

    public Square createSquare(int length) {
       return new SquareImpl(length);
    }
}
}}}

When using the `FactoryCreator` you can simply use:

{{{
SquareFactory squareFactory = factoryCreator.create(SquareFactory.class);
}}}

= Creating factories is easy. Why bother automating it? =

Although factory implementations are usually simple, they can be cumbersome because:

 # Hard to test - The instances created through the factory may be hard to setup and test.
 # Unnecessary classes - An implementation class needs to be written for every factory interface. This is tedious in and of itself. If you are tdding/[http://code.google.com/p/instinct/ bdding], each implementation also needs at least one [http://www.junit.org/ Test] [http://testng.org/doc/ Case].
 # Time wasted - All implementations need to pass the usual quality checks (eg. [http://checkstyle.sourceforge.net/ Checkstyle], [http://cobertura.sourceforge.net/ Code Coverage] etc)

= How does FactoryCreator locate implementations? =

Each method defined in a factory interface has the following form:

 {{{Returned_Interface Method_Name(Constructor_Arguments);}}}

Each implementation of the `Returned_Interface` is located as follows:

http://pinthura.googlecode.com/svn/wiki/images/FactoryCreator.png

If we take the `SquareFactory` as an example:

{{{
public interface SquareFactory {

    Square createSquare(int length);
}
}}}

{{{
Returned_Interface -> Square
Method_Name -> createSquare
Constructor_Arguments -> length
}}}

An implementation of `Square` will be located using a locator strategy. The constructor of the located class will then be called with `length`.

At the moment, the `FactoryCreator` finds implementations using two locator strategies:

 # By annotation. (`AnnotationLocatorImpl`)
 # By deriving the implementation class name. (`DerivedImplementationNameLocator`).

= How do I use the `AnnotationLocator` strategy? =

Taking a `WidgetFactory` as an example:

{{{
public interface WidgetFactory {

    @InterfaceImpl(CrazyWidget.class)
    Widget createWidget(Integer id);
}

 ...

 WidgetFactory  widgetFactory = factoryCreator.create(WidgetFactory .class);

}}}

When the `WidgetFactory` interface is passed to the `FactoryCreator` it uses the `AnnotationLocator` to find an instance of a class implementing the `Widget` interface. The implementation used in the above example uses the `InterfaceImpl` annotation to define its implementation class: `CrazyWidget`.

= How do I use the `DerivedImplementationNameLocator` strategy? =

Taking the `SquareFactory` as an example:

{{{
public interface SquareFactory {

    Square createSquare(int length);
}

 ...

 SquareFactory squareFactory = factoryCreator.create(SquareFactory.class);

}}}

When the `SquareFactory` interface is passed to the `FactoryCreator` it uses the `DerivedImplementationNameLocator` to find an instance of a class implementing the `Sqaure` interface. The default strategy for the `DerivedImplementationNameLocator` is the `ImplSuffixingDeriver`, which simply appends an *Impl* to the name of the interface (`Sqaure` -> `SquareImpl`).

= How do I extend the `DerivedImplementationNameLocator` to use another strategy instead of `ImplSuffixingDeriver`? =

Pass in your implementation of the `ClassNameDeriver` interface into the constructor of `DerivedImplementationNameLocator`.

= Where can I update the default locator strategies? =

The above default strategies are initialized in the the `InvocationFactoryImpl`
class:
{{{
public final class InvocationFactoryImpl implements InvocationFactory {

    private final List<ClassLocator> locators;
    private final MethodParamFactory factory;

    public InvocationFactoryImpl() {
        factory = new MethodParamFactoryImpl();
        locators = createDefaultLocators();
    }

    public InvocationFactoryImpl(final List<ClassLocator> locators) {
        factory = new MethodParamFactoryImpl();
        this.locators = locators;
    }

    ...

    private List<ClassLocator> createDefaultLocators() {
        List<ClassLocator> filters = new ArrayList<ClassLocator>();
        filters.add(new AnnotationLocatorImpl(new AnnotationFinderImpl()));
        filters.add(new DerivedImplementationNameLocator(new ImplSuffixingDeriver()));
        return filters;
    }
}
}}}

Calling the default constructor gives us the two default class locator strategies. If we want to customize these strategies we can pass in a list of our own `ClassLocator` implementations, through the second constructor.

The `ClassLocator` interface:

{{{
public interface ClassLocator extends FilterLink<MethodParam, Class<?>> {
}}}

= Examples =

 * [FactoryCreatorImplReportGenerator Report Generator]
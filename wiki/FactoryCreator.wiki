#summary Describes how to dynamically create factory implementations.
#labels Phase-Implementation,FactoryCreatorImpl,StartingPoint

== A Simple Example ==

Assume you have a `Square` interface:

{{{
public interface Square {

    int getLength();
    int getArea();
}
}}}

And an implementation:

{{{
public final class SquareImpl implements Square {

    private static final int SIDES_OF_SQUARE = 4;

    private final int length;

    public SquareImpl(final int length) {
        this.length = length;
    }

    public int getLength() {
        return SIDES_OF_SQUARE * length;
    }

    public int getArea() {
        return length * length;
    }
}
}}}

You now want to hide the instantiation of the `SquareImpl` behind a factory interface:

{{{
public interface SquareFactory {

    Square createSquare(int length);
 }
}}}

The `SquareFactory` is used in the `ShapeCanvas`:

{{{
public final class ShapeCanvas {

    private final SquareFactory squareFactory;
    private int canvasArea;

    public ShapeCanvas(final int canvasArea, final SquareFactory squareFactory) {
        this.canvasArea = canvasArea;
        this.squareFactory = squareFactory;
    }

    public int calcSquaresOnCanvas(int size) {
        Square square = squareFactory.create(size);
        int area = square.getArea();
        return canvasArea / area;
    }
}
}}}

The `ShapeCanvas` is run through the `ShapeCanvasRunner`:

{{{
public final class ShapeCanvasRunner {

    public static void main(final String[] args) {
        FactoryCreator factoryCreator = new FactoryCreatorImpl(new InvocationFactoryImpl());
        SquareFactory squareFactory = factoryCreator.create(SquareFactory.class);

        ShapeCanvas canvas = new ShapeCanvas(40, squareFactory);
        System.out.println("Number of squares: " + canvas.calcSquaresOnCanvas(2));
    }
}
}}}

This gives the following output:

{{{
Number of squares: 10
}}}

You have now created an instance of `SquareImpl` which is used in the `ShapeCanvas#calcSquaresOnCanvas` method, without using the `new` keyword or implementing the `SquareFactory` interface.

 * Why Hide the Instantiation of Objects in a Factory?

 # If you directly `new` up an instance of a class within another class, the class that uses the instance is tied to the implementation of the using class.

{{{
public final class ShapeCanvas {

    ...

    public int calcSquaresOnCanvas(int size) {
        Square square = new SquareImpl(size);
        int area = square.getArea();
        return canvasArea / area;
    }
}

}}}

In the above modified snippet the `ShapeCanvas` class now depends on the `SqaureImpl` class. Thus changing the the `SquareImpl` class directly affects the `ShapeCanvas`. This is not the case when using a factory as the implementation is hidden from the using class.
 
 # We also can't swap out the `SquareImpl` for another implementation of the `Sqaure` interface. We can do this via a factory as the factory returns a `Square` interface.

 # When testing we have to resort to state-bases tests as we can't mock out the `SquareImpl` class. We would then be testing both the `SquareImpl` class's `getArea()` method as well as the `ShapeCanvas`'s `calcSquaresOnCanvas()` method in the same test. Ideally we to test the `ShapeCanvas` in isolation which is not possible without mocks.

 * [FactoryCreatorImpl_Why_Need_FactoryCreator Why do I need the FactoryCreator?]
 * [FactoryCreatorImpl_Default_Locator_Strategies Where can I update the Default Locator Strategies?]

= Examples =

 * [FactoryCreatorImplReportGenerator Report Generator]
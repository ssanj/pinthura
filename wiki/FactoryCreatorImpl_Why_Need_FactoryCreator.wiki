#summary Why do I need a Factory anyways?
#labels Phase-Implementation

= Why do I need a Factory anyways? =

Using the keyword *new* when driving out code, makes interactions hard to test. Instances created within a test case and those created within the code proper are different. We are forced to resort to state-based testing in these scenarios. 

One way to get around this is by passing in a factory interface to abstract object creation. 

For example take a factory interface that creates Reports:

{{{
package com.googlecode.pinthura.factory.report;

public interface ReportFactory {

    Report create(Information info);
}
}}}

A `ReportGeneratorImpl` that uses the `ReportFactory`:

{{{
package com.googlecode.pinthura.factory.report;

public final class ReportGeneratorImpl implements ReportGenerator {

    private final ReportFactory reportFactory;

    public ReportGeneratorImpl(final ReportFactory reportFactory) {
        this.reportFactory = reportFactory;
    }

    public void generate(final Information info) {
        reportFactory.create(info).generate();
    }
}
}}}


When driving out the `ReportGeneratorImpl` class, we can quite easily mock out the `ReportFactory` and perform behaviour-based testing via mocks. See [http://www.easymock.org/ EasyMock], [http://www.jmock.org/ jMock]

At some point we need a concrete implementation of the `ReportFactory` interface. The class that implements this interface may be simple but can be hard to test if it interacts directly with concrete classes. Thus in many instances these Factory implementations are not tested or have rudimentary tests that simply create a new instance of an object.
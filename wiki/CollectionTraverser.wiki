#summary Separates the navigation of a Collection from its elements.
#labels Phase-Implementation,StartingPoint

= Introduction =

A `CollectionTraverser` abstracts the navigation of a `Collection` and allows the user to work on the elements of that `Collection`.

= A simple example =

Take a simple function that sums the `Integers` of a supplied `Collection`:

{{{
   Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
   Integer result = sum(numbers);
   assertThat(result, equalTo(15));

   ...
 
   public int sum(Collection<Integer> collection) {
      int total = 0;
      for (Integer number : collection) {
         total += number;
      }
      
      return total;
   }   
}}}

We could rewrite this with a `CollectionTraverser` as:

{{{
CollectionTraverser traverser = new CollectionTraverserImpl();
Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Integer result = traverser.forEach(numbers, new TotalHandler());
assertThat(result, equalTo(15));
}}}

If we have a look at `TotalHandler`:

{{{
public final class TotalHandler implements CollectionElementHandler<Integer, Integer> {

    private int total = 0;

    public void handle(final Integer element) {
        total += element;
    }

    public Integer getResult() {
        return total;
    }
}
}}}

and `CollectionElementHandler`:

{{{
public interface CollectionElementHandler<Input, Output> {

    void handle(Input element);
    Output getResult();
}
}}}

we see that there is no explicit code for navigating the `Collection`. Every `Collection` element (in this case an `Integer`) is passed to the 'handle(...)'  method of the `CollectionElementHandler`.

= Why separate `Collection` traversal logic? =

 # A loop is a natural logic boundary and should be separated where possible.
 # To stop repeating yourself (SRY). Java developers are constantly writing for loops!
 # Loops that exist within private methods can't be tested directly. They must be tested through public entry points. By extracting them into separate classes they are easier to test.
 # Processing logic of an element is more cohesive (since it can separated into its own class).

= This is so much longer than writing a for-loop. Why bother? =

 Granted that many IDES such as [http://www.jetbrains.com/idea/ Intellij] and [http://www.eclipse.org/ Eclipse] can automate the creation of template code for loops. That still does not prevent you from repeating yourself. It's just easier to repeat yourself in these cases!

 By separating logic for processing an element within a `Collection` you ensure creation of cohesive classes.

= How about a more complex example? =

Let's take a `DynamicMBean` implementation as an example:

{{{
public final class ContextAwareMBean implements DynamicMBean
    ...
    public MBeanInfo getMBeanInfo() {
        String name = this.getClass().getName();
        String description = this.description;
        MBeanConstructorInfo[] constructors = {};
        MBeanOperationInfo[] operations = {};
        MBeanNotificationInfo[] notifications = {};
        
        List<MBeanAttributeInfo> attributesList = buildAttributeList();
        MBeanAttributeInfo[] attributes = attributesList.toArray(new MBeanAttributeInfo[0]);
        return new MBeanInfo(name, description, attributes, constructors, 
                operations, notifications);
    }

    private List<MBeanAttributeInfo> buildAttributeList() {
        List<MBeanAttributeInfo> attributesList = new ArrayList<MBeanAttributeInfo>();
        for (Iterator i = properties.keySet().iterator(); i.hasNext();) {
            String propertyName = (String) i.next();
            if (propertyName.startsWith(context + "_")) {
                String attributeName = propertyName.substring(context.length() + 1);
                MBeanAttributeInfo attribute = new MBeanAttributeInfo(attributeName, String.class.getName(), "",true, true, false);
                attributesList.add(attribute);
            }
        }
        return attributesList;
    }

    ...
}}}

The entry point for testing this class is at the `getMBeanInfo()` method. The `buildAttributeList ()` method which does the bulk of the work can't be tested directly, as it is a private method.
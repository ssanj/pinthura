#summary Separates the navigation of a Collection from its elements.
#labels Phase-Implementation,StartingPoint

= Introduction =

A `CollectionTraverser` abstracts the navigation of a `Collection` and allows the user to work on the elements of that `Collection`.

= A simple example =

Take a simple function that sums the `Integers` of a supplied `Collection`:

{{{
   Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
   Integer result = sum(numbers);
   assertThat(result, equalTo(15));

   ...
 
   public int sum(Collection<Integer> collection) {
      int total = 0;
      for (Integer number : collection) {
         total += number;
      }
      
      return total;
   }   
}}}

We could rewrite this with a `CollectionTraverser` as:

{{{
CollectionTraverser traverser = new CollectionTraverserImpl();
Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Integer result = traverser.forEach(numbers, new TotalHandler());
assertThat(result, equalTo(15));
}}}

If we have a look at `TotalHandler`:

{{{
public final class TotalHandler implements CollectionElementHandler<Integer, Integer> {

    private int total = 0;

    public void handle(final Integer element) {
        total += element;
    }

    public Integer getResult() {
        return total;
    }
}
}}}

and `CollectionElementHandler`:

{{{
public interface CollectionElementHandler<Input, Output> {

    void handle(Input element);
    Output getResult();
}
}}}

we see that there is no explicit code for navigating the `Collection`. Every `Collection` element (in this case an `Integer`) is passed to the 'handle(...)'  method of the `CollectionElementHandler`.

= This is so much longer than writing a for-loop. Why bother? =

Granted that many IDES such as [http://www.jetbrains.com/idea/ Intellij] and [http://www.eclipse.org/ Eclipse] can automate the creation of template code for loops. That still does not prevent you from repeating the same iterative code. 

Some of the main reasons are:

 # A loop is a natural logic boundary (everything within the loop usually has a single purpose) and is a good candidate for extracting a (cohesive) class.
 # Loops that exist within private methods can't be tested directly. They must be tested through public entry points. By extracting them into separate classes they are easier to test.
 # To stop you from writing or generating the same code over and over.

= How about a more complex example? =

Let's take a `DynamicMBean` implementation as an example:

{{{
public final class ContextAwareMBean implements DynamicMBean
    ...
    public MBeanInfo getMBeanInfo() {
        String name = getClass().getName();
        String description = this.description;
        MBeanConstructorInfo[] constructors = {};
        MBeanOperationInfo[] operations = {};
        MBeanNotificationInfo[] notifications = {};
        
        List<MBeanAttributeInfo> attributesList = buildAttributeList();
        MBeanAttributeInfo[] attributes = attributesList.toArray(new MBeanAttributeInfo[0]);
        return new MBeanInfo(name, description, attributes, constructors, 
                operations, notifications);
    }

    private List<MBeanAttributeInfo> buildAttributeList() {
        List<MBeanAttributeInfo> attributesList = new ArrayList<MBeanAttributeInfo>();
        for (Iterator it = properties.keySet().iterator(); it.hasNext();) {
            String propertyName = (String) it.next();
            if (propertyName.startsWith(context + "_")) {
                String attributeName = propertyName.substring(context.length() + 1);
                MBeanAttributeInfo attribute = new MBeanAttributeInfo(attributeName, String.class.getName(), "",true, true, false);
                attributesList.add(attribute);
            }
        }
        return attributesList;
    }

    ...
}}}

The entry point for testing this class is at the `getMBeanInfo()` method. The `buildAttributeList ()` method which does the bulk of the work can't be tested directly, as it is a private method.

Using the `CollectionTraverser` we could do this:

{{{
public final class AttributeListBuilder implements CollectionElementHandler< MBeanAttributeInfo, List<MBeanAttributeInfo>> {

    private final List<MBeanAttributeInfo> attributesList = new ArrayList<MBeanAttributeInfo>();

    public void handle(final MBeanAttributeInfo info) {
            String propertyName = info.toString();
            if (propertyName.startsWith(context + "_")) {
                String attributeName = propertyName.substring(context.length() + 1);
                MBeanAttributeInfo attribute = new MBeanAttributeInfo(attributeName, String.class.getName(), "", true, true, false);
                attributesList.add(attribute);
            }
    }

    public List<MBeanAttributeInfo>> getResult() {
       return attributesList;
    }
}
}}}

The `AttributeListBuilder` class is quite simple and it is easier to test. The `ContextAwareMBean` is also simpler because it delegates building of the attribute list to the `AttributeListBuilder`. I've also hidden instantiation behind a `MBeanFactory`:

{{{
public final class ContextAwareMBean implements DynamicMBean

    public ContextAwareBean(CollectionTraverser traverser, MBeanFactory factory) {
       ...
    }

    ...

    public MBeanInfo getMBeanInfo() {
        List<MBeanAttributeInfo> attributesList = traverser.forEach(properties.keySet(), factory.createAttributeBuilder());
        //TODO: move this to the AttributeBuilder.
        MBeanAttributeInfo[] attributes = attributesList.toArray(new MBeanAttributeInfo[0]);

        return factory.createMBeanInfo(getClass().getName(), description, attributes);
    }

    ...
}
}}}
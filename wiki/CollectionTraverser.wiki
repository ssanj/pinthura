#summary Separates the navigation of a Collection from its elements.
#labels Phase-Implementation,StartingPoint

= Introduction =

A `CollectionTraverser` abstracts the navigation of a `Collection` and allows the user to work on the elements of that `Collection`.

= A simple example =

Take a simple function that sums the numbers of a supplied list:

{{{
CollectionTraverser traverser = new CollectionTraverserImpl();
Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Integer result = traverser.forEach(numbers, new TotalHandler());
assertThat(result, equalTo(15));
}}}

If we have a look at `TotalHandler`:

{{{
public final class TotalHandler implements CollectionElementHandler<Integer, Integer> {

    private int total = 0;

    public void handle(final Integer element) {
        total += element;
    }

    public Integer getResult() {
        return total;
    }
}
}}}

and `CollectionElementHandler`:

{{{
public interface CollectionElementHandler<Input, Output> {

    void handle(Input element);
    Output getResult();
}
}}}

We see that there is no explicit code for navigating the `Collection`. Every `Collection` element (in this case an `Integer`) is passed to implementation of the `CollectionElementHandler`.

This contrasts with the usual implementation which would be:

{{{
   public void handle(Collection<Integer> collection) {
      int total = 0;
      for (Integer number : collection) {
         total += number ;
      }
      
      return total;
   }   
}}}

= Why separate `Collection` traversal logic? =
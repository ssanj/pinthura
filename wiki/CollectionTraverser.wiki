#summary Separates the navigation of a Collection from its elements.
#labels Phase-Implementation,CollectionTraverser,StartingPoint

= Introduction =

A `CollectionTraverser` abstracts the navigation of a `Collection` and allows the user to work on the elements of that `Collection`.

= A simple example =

_This is a contrived example and you wouldn't normally use the `CollectionTraverser` to write something this simple_

Take a simple function that sums the `Integers` of a supplied `Collection`:

{{{
   Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
   Integer result = sum(numbers);
   assertThat(result, equalTo(15));

   ...
 
   public int sum(Collection<Integer> collection) {
      int total = 0;
      for (Integer number : collection) {
         total += number;
      }
      
      return total;
   }   
}}}

We could rewrite this with a `CollectionTraverser` as:

{{{
CollectionTraverser traverser = new CollectionTraverserImpl();
Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Integer result = traverser.forEach(numbers, new TotalHandler());
assertThat(result, equalTo(15));
}}}

If we have a look at `TotalHandler`:

{{{
public final class TotalHandler implements CollectionElementHandler<Integer, Integer> {

    private int total = 0;

    public void handle(final Integer element) {
        total += element;
    }

    public Integer getResult() {
        return total;
    }
}
}}}

and `CollectionElementHandler`:

{{{
public interface CollectionElementHandler<Input, Output> {

    void handle(Input element);
    Output getResult();
}
}}}

we see that there is no explicit code for navigating the `Collection`. Every `Collection` element (in this case an `Integer`) is passed to the 'handle(...)'  method of the `CollectionElementHandler`.

= This is so much longer than writing a for-loop. Why bother? =

You wouldn't use the `CollectionTraverser` for simple loops. It is to be used mainly for loops which are intermingled with other logic and is hard to test.
 
Granted that many IDES such as [http://www.jetbrains.com/idea/ Intellij] and [http://www.eclipse.org/ Eclipse] can automate the creation of template code, for loops. That still does not prevent you from repeating the same iterative code. It also doesn't make it any easier to test complex logic within a loop.

Some of the main reasons for using a `CollectionTraverser` are:

 # A loop is a natural logic boundary (everything within the loop usually has a single purpose) and is a good candidate for extracting a (cohesive) class (A `CollectionElementHandler` or `CollectionElementWithIndexHandler` implementation).
 # Loops that exist within private methods can't be tested directly. They must be tested through public entry points. Extracting separate classes, makes them easier to test.
 # To stop you from writing or generating the same code over and over.
 # To make your life easier by being given each `Collection` element [http://martinfowler.com/bliki/InversionOfControl.html (IOC)].

= How about a more complex example? =

Let's take a `DynamicMBean` implementation as an example:

{{{
public final class ContextAwareMBean implements DynamicMBean
    ...
    public MBeanInfo getMBeanInfo() {
        String name = getClass().getName();
        String description = this.description;
        MBeanConstructorInfo[] constructors = {};
        MBeanOperationInfo[] operations = {};
        MBeanNotificationInfo[] notifications = {};
        
        List<MBeanAttributeInfo> attributesList = buildAttributeList();
        MBeanAttributeInfo[] attributes = attributesList.toArray(new MBeanAttributeInfo[0]);
        return new MBeanInfo(name, description, attributes, constructors, 
                operations, notifications);
    }

    private List<MBeanAttributeInfo> buildAttributeList() {
        List<MBeanAttributeInfo> attributesList = new ArrayList<MBeanAttributeInfo>();
        for (Iterator it = properties.keySet().iterator(); it.hasNext();) {
            String propertyName = (String) it.next();
            if (propertyName.startsWith(context + "_")) {
                String attributeName = propertyName.substring(context.length() + 1);
                MBeanAttributeInfo attribute = new MBeanAttributeInfo(attributeName, String.class.getName(), "", true, true, false);
                attributesList.add(attribute);
            }
        }
        return attributesList;
    }

    ...
}}}

The entry point for testing this class is at the `getMBeanInfo()` method. The `buildAttributeList()` method which does the bulk of the work can't be tested directly - as it is a private method.

Using the `CollectionTraverser` we could do this:

{{{
public final class AttributeListBuilder implements CollectionElementHandler<MBeanAttributeInfo, List<MBeanAttributeInfo>> {

    private final List<MBeanAttributeInfo> attributesList = new ArrayList<MBeanAttributeInfo>();

    public AttributeListBuilder(final String context, final MBeanFactory factory) {
       ...
    }

    public void handle(final MBeanAttributeInfo info) {
            String propertyName = info.toString();
            if (propertyName.startsWith(context + "_")) {
                String attributeName = propertyName.substring(context.length() + 1);
                MBeanAttributeInfo attribute = factory.createMBeabAttributeInfo(attributeName, String.class.getName());
                attributesList.add(attribute);
            }
    }

    public List<MBeanAttributeInfo>> getResult() {
       return attributesList;
    }
}
}}}

The `AttributeListBuilder` class is quite simple and it is easier to test. The `ContextAwareMBean` is also simpler because it delegates building of the attribute list to the `AttributeListBuilder`. I've also hidden instantiation behind a `MBeanFactory`:

{{{
public final class ContextAwareMBean implements DynamicMBean

    public ContextAwareBean(CollectionTraverser traverser, MBeanFactory factory) {
       ...
    }

    ...

    public MBeanInfo getMBeanInfo() {
        List<MBeanAttributeInfo> attributesList = traverser.forEach(properties.keySet(), factory.createAttributeBuilder());
        //TODO: move this to the AttributeBuilder.
        MBeanAttributeInfo[] attributes = attributesList.toArray(new MBeanAttributeInfo[0]);

        return factory.createMBeanInfo(getClass().getName(), description, attributes);
    }

    ...
}
}}}

= Examples =